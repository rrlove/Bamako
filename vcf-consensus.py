'''
vcf-consensus

import vcf with vcf reader from pysan

for each locus in vcf, check that reference allele matches reference

specify individual

filter for quality and passing previous filters

calculate minor allele frequency, choose allele based on frequency of minor allele

write consensus sequence
'''

#!/usr/bin/env python

import argparse
from Bio import Seq
from Bio import SeqIO
import random
import unittest
import vcf

parser = argparse.ArgumentParser(description="Generate a consensus sequence from one or more samples in a VCF file, taking into account minor allele frequencies")

parser.add_argument('-v','--vcf', action="store", dest="vcfname", type=str, help='vcf file used to generate consensus sequence', required=True)
parser.add_argument('-o','--output', action="store", dest="outbase", type=str, help='prefix for output files', required=True)##to-do: make this not required, but default is sample name
parser.add_argument('-s','--sample', action="store", dest="samplelist", type=str, help='1 sample for which to generate a consensus', required=True)
parser.add_argument('-r','--reference', action="store", dest="reference", type=str, help='the reference sequence against which the VCF file was generated', required=True)
parser.add_argument('-q','--quality',action="store",dest="reference", type=float, help='minimum quality for considering a locus')##to-do: implement default

args = parser.parse_args()

vcf_reader = vcf.Reader(open(args.file,'r'))

reference = SeqIO.index(args.reference, "fasta")

try:
    ##make sure that the reference genome and the supplied VCF file have the same contigs
    assert set(vcf_reader.contigs.keys()) == set(reference.keys())
except:
    print "Error: contigs of reference and VCF do not match"
    raise SystemExit

##set a minimum quality to 30 x # samples if one is not supplied
if not args.quality:
    args.quality = 30 * len(vcf_reader.samples)

##make the Seq objects for the modified contigs that wil get written
outContigs = {}

for contig in vcf_reader.contigs.keys():
     outContigs[contig] = Seq("")

##keep track of where in the reference we last stopped
stoppedAt = 0##to-do: catch the transition between chromosomes!

for record in vcf_reader:
    
    if record.POS < stoppedAt:
        stoppedAt = 0
    
    ##add everything up to the position before the current locus
    outContigs[record.CHROM].seq += reference[record.CHROM].seq[stoppedAt:(record.POS-1)]
    ##make sure the reference alleles match in the reference genome and the VCF
    assert record.REF == reference[record.CHROM].seq[record.POS-1], "Error: reference and VCF do not match"    ##check this for off-by-one error
    
    ##ignore filtered sites and sites not passing the quality threshold
    if record.QUAL > args.quality and not record.FILTER:
    
        altFreq = 0
        cumAlts = 0
        cumReads = 0
        ##generate a random number to which to compare the alternate allele frequency
        testBound = random.uniform(0.0,1.0)
        
        for sample in args.sample:
            if len(record.genotype(sample)["AD"])==2:
                ##for a two-allele locus, the # of reads for the alternate will always be 2nd in the list generated by ["AD"]. To get the frequency,
                cumAlts += float(record.genotype(sample)["AD"][1])
                cumReads += float(sum(record.genotype(sample)["AD"]))
                ##altFreq += float(record.genotype(sample)["AD"][1])/float(sum(record.genotype(sample)["AD"]))
                
            elif len(record.genotype(args.sample)["AD"] > 2):
                print "Multi-allelic locus at " + record.CHROM + record.POS
                ##generate altFreq for multiallelic locus
        
        altFreq = cumAlts/cumReads
        
        if altFreq > testBound:
            outContigs[record.CHROM].seq += record.ALT
        elif altFreq <= testBound:
            outContigs[record.CHROM].seq += record.REF
        stoppedAt = record.POS+len(record.REF)-1##check this for off-by-one error,account for indels!
        
